Refer: https://rmolinamir.github.io/typescript-cheatsheet/#table-of-contents

1) Primitive & non-Primitive: 
  Primitive: number, string, boolean, symbol, null, or undefined.
  non-Primitive: other than all above e.g Object
  
2) Types:  
  String:
    const myName: string = 'Robert';
    
  Number:
    const myAge: number = 24;
    
  Boolean:
    const bHasHobbies: boolean = true;
    
  Array: 
    const hobbies: string[] = ['Programming', 'Cooking'];
    
  Tuples: Tuple types allow you to express an array where the type of a fixed number of elements is known, but need not be the same
    const address: [string, number] = ["Street", 99];
    
  Any:
    let myCar: any = 'BMW';
    
  Enums:
      enum Color {
        Gray, // 0
        Red, // 1
        Green = 100, // 100
        Blue, // 101
        Yellow = 2 // 2
      }
      const myColor: Color = Color.Green
      console.log(myColor); // Prints: 100
      
  Functions:
      function returnMyName(myName): string {
        return myName;
      }
      Argument types.:
        function multiply(value1: number, value2: number) {
          return value1 * value2;
        }
      Function types.:
        const myMultiply: (val1: number, val2: number) => number;
        
  Objects:
    let userData: { name: string, age: number }
    
  Complex Objects:
    let complex: { data: number[], output: (all: boolean) => number[] }
    
  Optional object properties:
    const right: { name: string, age?: number }
    
  Alias:
    type Complex = { data: number[], output: (all: boolean) => number[] };
    
  Union:
    let myRealRealAge: number | string = 24;
    
  Intersection:
    interface Loggable {
      log(name: string, age: number): void
    }
    interface Person {
      name: string
      age: number
      isStark?: boolean // May be undefined.
    }
    type LoggablePerson = Loggable & Person;
    
  Check:
    let finalValue = 'A string';
    if (typeof finalValue == 'string') {
      console.log('finalValue is a string');
    }
    
  Nullable:
     let canBeNull: null
     
  Never: The never type represents the type of values that never occur. 
    function neverReturns(): never {
      throw new Error('An error!');
    }

3) Type Assertions:
    const someValue: any = "this is a string";
    const strLength: number = (<string>someValue).length;
                        OR
    const strLength: number = (someValue as string).length;

4) ES6:
    Template Literals: 
      const userName = 'Robert';
      const greeting = `Hello I'm ${userName}`;
      
    Arrow Functions: 
      const greet = (name: string = 'Robert') => console.log(`Hello, ${name}`);
     
    Default Parameters:
      const greet = (name: string = 'Robert') => console.log(`Hello, ${name}`);
      
    Spread Operators:
      const numbers: number[] = [-3, 33, 38, 5];
      console.log(Math.min(...numbers));
     
    Array Destructuring:
      const testResults: number[] = [3.89, 2.99, 1.38];
      const [result1, result2, result3] = testResults;
    
    Object Destructuring: 
        const scientist: { firstName: string, experience: number } = { firstName: 'Robert', experience: 9000 };
        const { firstName, experience } = scientist;
     
 5) Classes:
      Accessors: Private, Public and Protected
        class Person {
           private type: string | null = null;
           protected age: number = 23;

           constructor(public name: string, public userName: string, private email: string) {
             this.name = name;
             this.userName = userName;
             this.email = email;
           }

           public printAge = () => {
             console.log(this.age);
             this.setType('Young guy');
           }

           private setType = (type: string) => {
             this.type = type;
             console.log(this.type);
           }
         }

         const person = new Person('Francisco', 'rmolinamir', 'example@email.com');
         person.printAge(); // Prints: 23
         // person.setType('Cool guy'); // Not possible, since setType is a private member of Person.
         
  Class Inheritance:
    class Robert extends Person {
      constructor(userName: string, email: string) {
        super('Robert Molina', userName, email);
        this.age = 25;
        this.printAge()
      }
    }
    
  Getters & Setters :
    class Plant {
      private _species: string = 'Default';
          get species() {
            return this._species;
          }
          set species(value: string) {
            if (value.length > 3) {
              this._species = value;
            } else {
              this._species = 'Default';
            }
          }
          public getSpecies = () => this._species
        }
  
  Static Properties & Methods: 
    class Helpers {
      static PI: number = 3.14;
      static calcCircumference(diameter: number): number {
        return this.PI * diameter;
      }
    }
    
  Abstract Classes:
    abstract class Project {
      projectName: string = 'Default';
      budget: number = 0;
      abstract changeName(name: string): void;
      calcBudget() {
       return this.budget * 2;
      }
    }
    
 Private Constructors & Singletons:
    class OnlyOne {
      private static instance: OnlyOne;
      private constructor(public readonly name: string) {}
      static getInstance() {
        if (!OnlyOne.instance) {
          OnlyOne.instance = new OnlyOne('The Only One');
        }
        return OnlyOne.instance;
      }
    }

6) Modules:
      All the code add in file are enclosed in a module for using in external file we need to export and import
      
    Export: 
        export const PI = 3.14;
        export const calculateCircumference = (diameter: number) => {
          return diameter * PI;
        }
        export interface IAppState {
          counterValue: number;
        }
        
    Default Exports:
        const calculateRectangle = (width: number, length: number) => {
          return width * length;
        }
        export default calculateRectangle;
        
    Import:
      import { PI, calculateCircumference } from './src/circle';
      import calculateRectangle from './src/rectangle'; // default export
      
    Advanced Module Loading: In some cases, you may want to only load a module under some conditions.
      System:
        declare const System: any;

         import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

         if (needZipValidation) {
             System.import("./ZipCodeValidator").then((ZipCodeValidator: typeof Zip) => {
                 var x = new ZipCodeValidator();
                 if (x.isAcceptable("...")) { /* ... */ }
             });
         }
         
7) Namespace:
    Anywhere the module keyword was used when declaring an internal module, the namespace keyword can and should be used instead.
     namespace MyMath {
         export namespace Circle {
           export const PI = 3.14;
           export const calculateCircumference = (diameter: number) => {
             return diameter * PI;
           }
         }
       }
          /// <reference path="./src/circleMath.ts" />
         /// <reference path="./src/rectangleMath.ts" />
         import Circle = MyMath.Circle;
         import calculateRectangle = MyMath.Rectangle.calculateRectangle;
         
8) Manually declaring a third party library:
    Crate file : jquery.d.ts
                 declare var $: any;
                 
9) Interfaces:
    interface SimplePerson {
      firstName: string;
    }
    
    Optional Properties:
      interface SimplePerson {
        firstName: string;
        lastName?: string;
        age?: number;
      }
      
    Index Signatures (Dynamic Property Names):
      interface NamedPerson {
        firstName: string;
        age?: number;
        [propName: string]: any;
      }
      
    Implements Keyword:
      interface NamedPerson {
        firstName: string;
        age?: number;
      }
      class Person implements NamedPerson {
        constructor(public firstName: string, public lastName: string) {}
        greet(lastName: string) {
          console.log(`Hi, I am ${this.firstName} ${lastName}!`);
        }
      }
      
    Extend Keyword:
        class Control {
            private state: any;
        }

        interface SelectableControl extends Control {
            select(): void;
        }

        class Button extends Control implements SelectableControl {
            select() { }
        }

    Implementing an interface to a function:
        interface DoubleValueFunc {
          (number1: number, number2: number): number;
        }

        let myDoubleFunction: DoubleValueFunc;
        myDoubleFunction = (num1: number, num2: number) => {
            return (num1 + num2) * 2;
        }

        console.log(myDoubleFunction(10,50)); // Prints: 120
        
    Omit type when extending an interface:
      Sometimes, we might want to omit certain types from an extended interface. One of the most common reasons is to overwrite a property.
      
      type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>
      /**
        * Base interface.
      */
      type InputElementAttributes = React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;

      interface IInputProps extends IInputState, Omit<InputElementAttributes, 'onChange'> {
        onChange: (value?: value) => void
      }
    
    Type checking for interfaces:
      function isFish(pet: Fish | Bird): pet is Fish {
        return (<Fish>pet).swim !== undefined;
      }
   
10) Generics:
      Built-in Generics:
        const testResults: Array<number> = [1.94, 2.33];
        
        Generic Types:
                function betterEcho<T>(data: T) {
                    return data;
                  }

                 const echoStr: <T>(data: T) => T = betterEcho;
                 console.log(echoStr<string>('Hello world!').toLocaleUpperCase()); // Prints: "HELLO WORLD!"

                 const echoNum: <T>(data: T) => T = betterEcho;
                 console.log(echoNum<number>(312).toString()); // Prints: "312"
                 
        Interfaces:
            interface GenericIdentityFn<T> {
              (arg: T): T;
            }

            function identity<T>(arg: T): T {
              return arg;
            }

            let myIdentity: GenericIdentityFn<number> = identity;
            
       Generic Class:
          class GenericMath<T extends number | string> {
              constructor(public baseValue: T, public multiplyValue: T) {}
              calculate(): number {
                return +this.baseValue * +this.multiplyValue
              }
           }
           const onlyNumbers = new GenericMath<number>(10, 20);
           const onlyStrings = new GenericMath<string>('10', '20');
           const bothTypes = new GenericMath<number | string>(10, '20');
           
11) Decorators: (enhance the functionality)
        A Decorator is a special kind of declaration that can be attached to a class declaration, method, accessor, property, or parameter. Decorators use the form @expression, where expression must evaluate to a function that will be called at runtime with information about the decorated declaration.
        
        tsconfig.json
        {
            "compilerOptions": {
                "target": "ES5",
                "experimentalDecorators": true
            }
        }           
       
       Class Decorators : 
    
        function logged(constructorFn: Function) {
            console.log(constructorFn); // Will log the class Person constructor.
         }

        @logged
        class Person {
          constructor() {
            console.log('Hi!');
          }
        }
        O/P : 
          Æ’ Person()
        
        Factory: 
          function logging(value: boolean) {
            return value ? logged : () => {console.log('not called')}
          }
          
          @logging(true) // If true, it will return the `logged` decorator, if false, it will execute an empty function.
          class Car {
          }
          O/P:
            f Car()
          
          @logging(false) // If true, it will return the `logged` decorator, if false, it will execute an empty function.
          class Car {
          }
          o/p:
            'not called'
            
        Add function in class: 
          function addPrint(constructorFn: Function) {
              constructorFn.prototype.print = function () {
                this.name = "Maruti"
              }
          }
          
          @addPrint
          class Car {
            private name = 'Suzuki
          }
          const c = new Car()
          (<any>c).print();
          o/p: 
            'Suzuki'
            
        Freez object :
          function Frozen(constructor: Function) {
            Object.freeze(constructor);
            Object.freeze(constructor.prototype);
          }
          
          @Frozen
          Class Tree {}
          
          Class Plat extend Tree {} // throws error
     
     Method Decorator:
     
          function ConfirmMsg(message: string) {
            return function(target: Object, key: string | symbol, descriptor: PropertyDescriptor) {
              const original = descriptor.value;
              console.log('-->',target, key);
              descriptor.value = function (...args: any[]) {
                const allow = confirm(message);
                if(allow) {
                  const result = original.apply(this, args);
                  return result;
                } else {
                  return null;
                }
              }
            }
          }

          class Classic {
            private missions: string[] = [];
            @ConfirmMsg('Run')
            addMontag(misson: string) {
              this.missions.push(misson);
              return this.missions;
            } 
          }

          const c = new Classic();
          console.log(c.addMontag('pop'));
      
